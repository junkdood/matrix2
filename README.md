# 描述
写时复制(Copy-on-write): 当你读取到这个空间的时候，并不会开辟出一个一模一样的空间出来给你，当你真正需要拷贝的时候，那么他就会开辟出空间给你。也就是拖延版的深拷贝。

写时复制(是通过"引用计数"实现的，在分配空间的时候多分配4个字节，用来记录有多少个指针指向块空间，当有新的指针指向这块空间时，引用计数加一，当要释放这块空间时，引用计数减一(假装释放)，直到引用计数减为0时才真的释放掉这块空间。当有的指针要改变这块空间的值时，再为这个指针分配自己的空间(注意这时引用计数的变化，旧的空间的引用计数减一，新分配的空间引用计数加一)

写时复制的好处是结合和浅拷贝和深拷贝的优点，对只读对象，可以十分迅速的完成对象拷贝，对需要修改的对象，可以延迟到实际修改的时候才进行内存空间的申请，分摊了系统调用的时间。

完成一个栈类，栈的复制采用写时复制规则 注意内存回收（40分）

> #ifndef STACK_HPP  
> #define STACK_HPP  
> #include <stddef.h>  
> class Stack {  
>   struct node {  
>     int num;  
>     node* next;  
>     node() { num = 0; next = NULL; }  
>     node(int n, node* p = NULL) { num = n; next = p; }  
>   };  
>   
>   struct {                        // 匿名结构体  
>     node* data;                   // 栈指针  
>     int* count;                   // 写时复制的计数器  
>   } p;  
>   
>   void copyOnWrite();             // 写时复制函数，在修改数据时调用该函数进行深拷贝  
> public:  
>   Stack();                        // 构造一个空栈  
>   Stack(const Stack&);            // 写时复制规则  
>   ~Stack();                       // 注意内存回收  
>   
>   Stack operator=(const Stack&);  // 写时复制规则  
>   void push(int);                 // 入栈  
>   void pop();                     // 出栈  
>   int top() const;                // 查看栈顶元素  
>   bool empty() const;             // 判断栈是否为空  
>   void clear();                   // 清空栈  
> };  
> #endif  
# 提示
下图是写时复制的示意图。

第一步：有对象s1, 指向一个内存空间 [3, 2, 1]，该空间的计数器为1，表示只有一个对象指向该空间

第二步：s2 = s1, 此时s2和s1共同指向一个内存空间，采用浅拷贝规则，该空间计数器为2，表示有两个对象指向该空间

第三步：当s1或s2需要改变数据时（比如，s2出栈），那么改变数据的对象进行深拷贝后再执行改变数据操作

当内存空间计数器 1->0 时，需要对该内存空间进行回收

file
